<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>预备知识</title>
    <link href="/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言进阶语法</title>
    <link href="/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言进阶语法"><a href="#go语言进阶语法" class="headerlink" title="go语言进阶语法"></a>go语言进阶语法</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言中不存在指针操作，只需要记住两个符号：&amp;取地址，*根据地址取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类似C语言实现指针传值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify2</span><span class="hljs-params">(x *<span class="hljs-keyword">int</span>)</span></span> &#123;<br>*x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br>modify1(a)<br>fmt.Println(a) <span class="hljs-comment">// 10</span><br>modify2(&amp;a)<br>fmt.Println(a) <span class="hljs-comment">// 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>首先我们看个代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>b[<span class="hljs-string">&quot;重邮&quot;</span>] = CQUPT<br>fmt.Println(b)<span class="hljs-comment">//无法运行</span><br></code></pre></td></tr></table></figure><p>​      在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><blockquote><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>*a = <span class="hljs-number">10</span><br>fmt.Println(*a)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><blockquote><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><br>s1= <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>fmt.Println(s1)<br></code></pre></td></tr></table></figure><h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><ol><li>make和new都是用来申请内存的</li><li>new很少用，一般用来给基本数据类型申请内存，int，返回的是对应指针*int</li><li>make是用来给slice、map、chan申请内存的，make函数返回的是类型本身</li></ol><h2 id="字典map—用空间换时间"><a href="#字典map—用空间换时间" class="headerlink" title="字典map—用空间换时间"></a>字典map—用空间换时间</h2><p>基本上所有的编程语言都自带一种数据结构，它主要提供一个快速的查找，插入，删除，具备与存储体量无关的O（1）的性能，并且支持key上面的唯一性。go也原生提供了一个类似的数据类型，就叫做map。</p><p>关键点：</p><ol><li>map 是由 <code>key-value</code> 对（键值对）组成的</li><li>key 只会出现一次。</li><li>Go语言中的map是引用类型，必须初始化才能使用</li></ol><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// 声明一个key和string是string类型的map</span><br><span class="hljs-keyword">var</span> m1 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<span class="hljs-comment">//声明+初始化-在内存中开辟空间</span><br><span class="hljs-keyword">var</span> m3 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;lastname&quot;</span>: <span class="hljs-string">&quot;Leng&quot;</span>, <span class="hljs-string">&quot;firstname&quot;</span>: <span class="hljs-string">&quot;yusen&quot;</span>&#125;<span class="hljs-comment">//声明+初始化+赋值,也可以通过索引对相应的值进行赋值 m3[&quot;lastname&quot;]=&quot;re&quot;</span><br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>类似数组和切片， map 的读取类似 slice，通过 key 来操作，只是 slice 的index （下标或者叫索引）只能是int类型。</p></blockquote><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := <span class="hljs-keyword">map</span>[key]<span class="hljs-comment">//约定俗成用ok接收返回的布尔值</span><br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">scoreMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>scoreMap[<span class="hljs-string">&quot;张三&quot;</span>] = <span class="hljs-number">90</span><br>scoreMap[<span class="hljs-string">&quot;小明&quot;</span>] = <span class="hljs-number">100</span><br><span class="hljs-comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br>v, ok := scoreMap[<span class="hljs-string">&quot;张三&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(v)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;查无此人&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h4><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k,v)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for —_,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, key)<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是把一段逻辑抽象出来封装到一个函数中，使代码更简洁</p><p>具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(参数)</span><span class="hljs-params">(返回值)</span></span>&#123;<br>    函数体<br>&#125;<br><span class="hljs-comment">//返回值参数可命名，也可不命名，命名的返回值相当于在函数中声明变量</span><br></code></pre></td></tr></table></figure><p>特别注意可变长参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum2</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(x) <span class="hljs-comment">//x是一个切片，可以传多个参数 </span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x &#123;<br>sum = sum + v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言基础语法</title>
    <link href="/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>我们利用变量将这个数据的内存地址保存起来，以后可以直接通过这个变量就能找到内存上对应的数据了。</p></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量有不同的类型，对应存储不同的数据类型：</p><p>常见的有以下几种：</p><ul><li><p>bool: 布尔型的值<strong>只</strong>可以是常量 true 或者 false</p></li><li><p><code>int</code>：存放整数</p><p>​          八进制以0开头     十六进制用ox开头</p></li><li><p><code>float32/float64(默认)</code>: 存放小数，两者不能直接互相赋值</p></li><li><p><code>string</code>: 存放一串字符</p></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Go语言中变量必须先声明再使用</p><p>我们用关键字<code>var</code>用于声明变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> <br><span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span> = <span class="hljs-number">9</span> <span class="hljs-comment">//声明并赋值，不赋值的话默认是初始值</span><br><span class="hljs-keyword">var</span> a, b, c <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;I&#x27;m a&quot;</span>, <span class="hljs-string">&quot;I&#x27;m b&quot;</span>, <span class="hljs-string">&quot;I&#x27;m c&quot;</span> <span class="hljs-comment">//也可以同时声明多个变量并赋值</span><br><span class="hljs-keyword">var</span> x, y = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">//也可以不指定变量的类型直接赋值，此时go语言会根据你赋予的值自动判断变量类型</span><br>num := <span class="hljs-number">123</span><br>str := <span class="hljs-string">&quot;Lengyusen&quot;</span> <span class="hljs-comment">//也可以用短声明:=来自动判断类型，只能在函数内用(常用)</span><br><span class="hljs-keyword">var</span>(<br>    name <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int</span><br>)<span class="hljs-comment">//批量声明</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Go语言中非全局变量声明了必须使用，不使用就无法编译</li><li>Go语言中推荐使用驼峰命名 如：studentName</li><li>关键词不能当作变量名</li><li>同一个作用域变量不能重复声明</li></ul><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量，用一个下划线<code>_</code>表示。不占用命名空间，不会分配内存</p><h2 id="常量与iota"><a href="#常量与iota" class="headerlink" title="常量与iota"></a>常量与iota</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><span class="hljs-comment">//和var一样，多个常量也可以一起声明</span><br><span class="hljs-keyword">const</span> (<br>    pi = <span class="hljs-number">3.1415</span><br>    e = <span class="hljs-number">2.7182</span><br>)<br></code></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><blockquote><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中<strong>每新增一行</strong>常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p></blockquote><p>几个常见的<code>iota</code>示例:</p><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2        <span class="hljs-comment">//1</span><br>_<br>n4        <span class="hljs-comment">//3</span><br>)<br></code></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2 = <span class="hljs-number">100</span>  <span class="hljs-comment">//100</span><br>n3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span><br>n4        <span class="hljs-comment">//3</span><br>)<br><span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_  = <span class="hljs-literal">iota</span><br>KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<span class="hljs-comment">//将1的二进制表示向左移10位</span><br>MB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>GB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>TB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>PB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>)<br></code></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//1,2</span><br>c, d                      <span class="hljs-comment">//2,3</span><br>e, f                      <span class="hljs-comment">//3,4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h3><ul><li>%T 查看类型</li><li>%v 查看变量值(万能)</li><li>%d 查看十进制</li><li>%b 查看二进制</li><li>%o 查看八进制</li><li>%x 查看十六进制</li><li>%s 查看字符串</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中字符串用双引号包裹的，而单引号包裹的是字符。当定义一个多行字符串时，需要用到`符号(键盘上ESC下面的键)，但是对所有的转义字符均无效，文本会原样输出。</p><h4 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h4><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>​      要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;我爱Go语言&quot;</span><br> s2:= []<span class="hljs-keyword">rune</span>(s1)<span class="hljs-comment">//把字符串强制转化为rune切片</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;你&#x27;</span><br>fmt.Println(<span class="hljs-keyword">string</span>(runeS2))<span class="hljs-comment">//把rune切片强制转化为字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1结果为true时，执行此处代码  </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-comment">//当条件表达式2结果为true时，执行此处代码 </span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1，2结果为false时，执行此处代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环使Go语言中唯一的循环语句</p><pre><code> for循环的基本格式如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 初始语句;条件表达式;结束语句&#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><p>​    条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<span class="hljs-comment">//常用</span><br></code></pre></td></tr></table></figure><p>​    for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(i)<br>i++<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><p>​    无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。(一个break只能结束一层for循环)</li><li>for循环可以通过continue语句跳过此次循环。</li></ul><p>​    for range循环(键值循环)</p><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s:=<span class="hljs-string">&quot;Hello Leng&quot;</span><br><span class="hljs-keyword">for</span> i,v:=<span class="hljs-keyword">range</span> s&#123;<br>fmt.printf(<span class="hljs-string">&quot;%d %c\n&quot;</span>,i,v);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><p>​    使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo1</span><span class="hljs-params">()</span></span> &#123;<br>finger := <span class="hljs-number">3</span><br><span class="hljs-keyword">switch</span> finger &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>fmt.Println(<span class="hljs-string">&quot;大拇指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>fmt.Println(<span class="hljs-string">&quot;食指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>fmt.Println(<span class="hljs-string">&quot;中指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>fmt.Println(<span class="hljs-string">&quot;无名指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>fmt.Println(<span class="hljs-string">&quot;小拇指&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;无效的输入！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>​    一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testSwitch3</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := <span class="hljs-number">7</span>; n &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo4</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">30</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> age &lt; <span class="hljs-number">25</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好学习吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">25</span> &amp;&amp; age &lt; <span class="hljs-number">35</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好工作吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好享受吧&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;活着真好&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo5</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;a&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;b&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;c&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;c&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><blockquote><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。</p></blockquote><p> 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-comment">// 设置退出标签</span><br><span class="hljs-keyword">goto</span> breakTag<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v-%v\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-comment">// 标签</span><br>breakTag:<br>fmt.Println(<span class="hljs-string">&quot;结束for循环&quot;</span>)<br><span class="hljs-comment">//尽量少用</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p></blockquote><p>我们可以在给数组声明的同时赋值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [<span class="hljs-number">5</span>]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-string">&quot;Max&quot;</span>&#125; <span class="hljs-comment">//括号中初始化的元素个数不能大于数组的大小</span><br></code></pre></td></tr></table></figure><p>还可以不设置数组大小，Go 语言会自动根据元素的个数来设置数组的大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [...]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><blockquote><p>​        Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。切片是引用类型，不保存具体的值，都指向了底层的数组，如果修改切片，底层数组也会被修改。<strong>总而言之，切片就是一个框，框柱了一块连续的内存，切片属于引用类型，真正的数据都是保存在底层的数据之中的。</strong></p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name []T<br><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><span class="hljs-comment">//存放int类型数据的切片</span><br>s1=[]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h3><blockquote><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p></blockquote><ul><li>长度指的是切片中的元素个数</li><li>容量指的是切片对应的底层数组的元素个数，是底层数组从切片的第一个元素到最后一个元素的元素数量。</li></ul><h3 id="如何得到切片"><a href="#如何得到切片" class="headerlink" title="如何得到切片"></a>如何得到切片</h3><h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">a1:=&#123;...&#125;<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>&#125;<br>s1:=a1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7]基于一个数组切割，左包含右不包含</span><br>s2:=a1[:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7] =&gt;[0:4]</span><br>s3:=a1[<span class="hljs-number">3</span>:]<span class="hljs-comment">//[7 9 11 13] =&gt;[3:len(a1)]</span><br>s4:=a1[:]<span class="hljs-comment">//[1 3 5 7 9 11 13] =&gt;[0:len(a1)]</span><br></code></pre></td></tr></table></figure><h4 id="make-函数创造切片"><a href="#make-函数创造切片" class="headerlink" title="make( ) 函数创造切片"></a>make( ) 函数创造切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">//长度为2，容量为10</span><br>fmt.Println(a)      <span class="hljs-comment">//[0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">//2</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(a)) <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><h4 id="索引遍历"><a href="#索引遍历" class="headerlink" title="索引遍历"></a>索引遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>fmt.Println(i, s[i])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for-range遍历"><a href="#for-range遍历" class="headerlink" title="for  range遍历"></a>for  range遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Println(index, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="append-为切片追加元素"><a href="#append-为切片追加元素" class="headerlink" title="append( )为切片追加元素"></a>append( )为切片追加元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)        <span class="hljs-comment">// [1]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">// [1 2 3 4]</span><br>s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;  <br>s = <span class="hljs-built_in">append</span>(s, s2...)    <span class="hljs-comment">// [1 2 3 4 5 6 7] ...表示拆开</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>我们需要用原切片变量接收返回值，当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。</li><li>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</li><li>Go语言中无删除切片元素的方法，可以利用append()函数把不要的元素切掉，此时底层数组也会被修改</li><li>通过切片会改变底层数组，拷贝前后两个切片共享底层数组，对一个切片的修改会影响另一个切片的内容。而使用copy函数可以防止此情况。</li><li>可以使用sort.Ints(s[:])对切片进行排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2021/11/14/%E6%A0%91/"/>
    <url>/2021/11/14/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种分支结构，逻辑上是一对多，具有明显的递归特性。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>结点：包含一个数据元素和若干指向子树的分支</li><li>结点的度：结点上分支的个数</li><li>数的度：所有结点的最大分支数(结点度的最大值)</li><li>叶子节点：度为零的节点(末端)</li><li>双亲、孩子：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</li><li>森林：多棵树放在一起</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的每个结点至多只有两棵子树，且子树有左右之分，次序不能颠倒</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>满二叉树：除了最底层每个结点都有左右两个孩子</li><li>完全二叉树：满二叉树从最底层开始从右往左删除结点，满二叉树是特殊的完全二叉树</li></ul><h4 id="求完全二叉树的高度-h"><a href="#求完全二叉树的高度-h" class="headerlink" title="求完全二叉树的高度(h)"></a>求完全二叉树的高度(h)</h4><p>解此类问题重在分析结点与高度之间的关系</p><p>1.先分析满二叉树</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\F06C28DB02E9D1EBA4077DD627BC071A.jpg"></p><p>2.一般的完全二叉树</p><p>​     方法①：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\B520005BA6A661BC36A5CBFEB8260729.jpg"></p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\C79655C54222BEC83BCDD60A33FBEC0E.jpg"></p><p>​     方法②：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\14F0AF8E1F1DD63E69940BA566D8B5B7.jpg"></p><p>综上有两个公式(我偏向于记忆第一个，因为第一个更便于理解)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\56EB97FA5643D36AB5D969D00686A794.jpg"></p><p>​                （注：第一个是向下取整，第二个是向上取整）</p><h3 id="二叉树的一些性质"><a href="#二叉树的一些性质" class="headerlink" title="二叉树的一些性质"></a>二叉树的一些性质</h3><ul><li><p>总分支数=总结点数-1</p><p>   叶结点个数为N0</p><p>   单分枝结点个数为N1</p><p>   双分支结点个数为N2</p></li><li><p>总结点数=N0+N1+N2</p></li><li><p>总分支数=N1+2N2</p><p>   <strong>从而解得：N0=N2+1</strong></p><p>​                     <strong>叶子结点数=双分支节点数+1</strong></p><p>（普通树可用同样的方法类比：N0=1+N2+2N3+…+(m-1)Nm）</p></li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>把每个结点存入数组之中(但只对完全二叉树适用)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\6879E5CA54A244F6D9F13F05AD430235.jpg"></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>首先我们看看树的链式存储结构，用链表存储孩子结点的信息</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\31C74FFF31C21E4792E95A574724EBFF.jpg"></p><p>​     然后我们看二叉树，则可以表链表的长度取成二，但我们之所以用链表来存储数的信息，是因为链表方便存储不确定个数的信息。而我们现在已经知道了二叉树最多只有两个子树，所以我们可以直接定义两个指针来指向左右两个孩子。</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\1A256C933F8626A252683FEDD01EB861.jpg"></p><h3 id="数与二叉树的相互转换"><a href="#数与二叉树的相互转换" class="headerlink" title="数与二叉树的相互转换"></a>数与二叉树的相互转换</h3><p>​     方法：将数转化为二叉树：首先将每个结点与其兄弟结点相连，然后只留下最左边的连线，删去其他连线，最终形成的二叉树左边的连线是连的孩子，右边的连线是连的兄弟。而将二叉树转化为树则与上述操作相反即可，补全与双亲的连线，删去与兄弟的连线。下图是将树转化为二叉树的一个事例：</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\FB481DD3FAD88556E1850D77BCC54920.jpg" style="zoom:33%;"><h3 id="森林与二叉树的相互转换"><a href="#森林与二叉树的相互转换" class="headerlink" title="森林与二叉树的相互转换"></a>森林与二叉树的相互转换</h3><p>  方法：森林转化为二叉树：首先将森林中的每棵数都先转化为二叉树，则每棵二叉树根节点的左边接的是子树，右边为空，然后就可以让右边接下一棵树的根节点。而将二叉树转换为森林即实现相反操作。</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\0163938A33B279A3770AB24ED6D120FB.jpg" style="zoom: 25%;"><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>层次遍历(广度优先遍历)：从上至下，从左至右</p></li><li><p><em><strong>前序遍历：根-左-右</strong></em></p></li><li><p><em><strong>中序遍历：左-根-右</strong></em></p></li><li><p><em><strong>后序遍历：左-右-根</strong></em></p></li></ul><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\7B0ACC7E9692F5401BB179C67F32438C.jpg"></p><p>​        树的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\2FAE304F42ECD1CA3B8DF1C394672E85.jpg"></p><p>​        森林的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\3C551A4C1BE1291709BC8F848781898A.jpg"></p><h4 id="递归函数基础"><a href="#递归函数基础" class="headerlink" title="递归函数基础"></a>递归函数基础</h4><p>函数自己调用自己</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\EEC46EE6479E306BFF6318E5232F51BD.jpg"></p><h4 id="二叉树遍历以代码实现"><a href="#二叉树遍历以代码实现" class="headerlink" title="二叉树遍历以代码实现"></a>二叉树遍历以代码实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
