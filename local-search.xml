<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>预备知识</title>
    <link href="/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>指针就是地址，地址就是指针</li><li>指针变量是存放内存单元地址的变量</li><li>指针的本质是一个操作受限的非负整数</li></ul><h2 id="基本类型的指针"><a href="#基本类型的指针" class="headerlink" title="基本类型的指针"></a>基本类型的指针</h2><h2 id="指针和数组之间的关系"><a href="#指针和数组之间的关系" class="headerlink" title="指针和数组之间的关系"></a>指针和数组之间的关系</h2><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h1 id="动态内存的分配和释放"><a href="#动态内存的分配和释放" class="headerlink" title="动态内存的分配和释放"></a>动态内存的分配和释放</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言进阶语法</title>
    <link href="/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言进阶语法"><a href="#go语言进阶语法" class="headerlink" title="go语言进阶语法"></a>go语言进阶语法</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言中不存在指针操作，只需要记住两个符号：&amp;取地址，*根据地址取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类似C语言实现指针传值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify2</span><span class="hljs-params">(x *<span class="hljs-keyword">int</span>)</span></span> &#123;<br>*x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br>modify1(a)<br>fmt.Println(a) <span class="hljs-comment">// 10</span><br>modify2(&amp;a)<br>fmt.Println(a) <span class="hljs-comment">// 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>首先我们看个代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>b[<span class="hljs-string">&quot;重邮&quot;</span>] = CQUPT<br>fmt.Println(b)<span class="hljs-comment">//无法运行</span><br></code></pre></td></tr></table></figure><p>​      在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><blockquote><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>*a = <span class="hljs-number">10</span><br>fmt.Println(*a)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><blockquote><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><br>s1= <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>fmt.Println(s1)<br></code></pre></td></tr></table></figure><h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><ol><li>make和new都是用来申请内存的</li><li>new很少用，一般用来给基本数据类型申请内存，int，返回的是对应指针*int</li><li>make是用来给slice、map、chan申请内存的，make函数返回的是类型本身</li></ol><h2 id="字典map"><a href="#字典map" class="headerlink" title="字典map"></a>字典map</h2><p>基本上所有的编程语言都自带一种数据结构，它主要提供一个快速的查找，插入，删除，具备与存储体量无关的O（1）的性能，并且支持key上面的唯一性。go也原生提供了一个类似的数据类型，就叫做map。</p><p>关键点：</p><ol><li>map 是由 <code>key-value</code> 对（键值对）组成的</li><li>key 只会出现一次。</li><li>Go语言中的map是引用类型，必须初始化才能使用</li></ol><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// 声明一个key和string是string类型的map</span><br><span class="hljs-keyword">var</span> m1 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<span class="hljs-comment">//声明+初始化-在内存中开辟空间</span><br><span class="hljs-keyword">var</span> m3 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;lastname&quot;</span>: <span class="hljs-string">&quot;Leng&quot;</span>, <span class="hljs-string">&quot;firstname&quot;</span>: <span class="hljs-string">&quot;yusen&quot;</span>&#125;<span class="hljs-comment">//声明+初始化+赋值,也可以通过索引对相应的值进行赋值 m3[&quot;lastname&quot;]=&quot;re&quot;</span><br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>类似数组和切片， map 的读取类似 slice，通过 key 来操作，只是 slice 的index （下标或者叫索引）只能是int类型。</p></blockquote><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := <span class="hljs-keyword">map</span>[key]<span class="hljs-comment">//约定俗成用ok接收返回的布尔值</span><br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">scoreMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>scoreMap[<span class="hljs-string">&quot;张三&quot;</span>] = <span class="hljs-number">90</span><br>scoreMap[<span class="hljs-string">&quot;小明&quot;</span>] = <span class="hljs-number">100</span><br><span class="hljs-comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br>v, ok := scoreMap[<span class="hljs-string">&quot;张三&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(v)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;查无此人&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h4><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k,v)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for —_,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, key)<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是把一段逻辑抽象出来封装到一个函数中，使代码更简洁</p><p>具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(参数)</span><span class="hljs-params">(返回值)</span></span>&#123;<br>    函数体<br>&#125;<br><span class="hljs-comment">//返回值参数可命名，也可不命名，命名的返回值相当于在函数中声明变量</span><br></code></pre></td></tr></table></figure><p>比如带参数和返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>,y <span class="hljs-keyword">int</span>)</span><span class="hljs-title">int</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-comment">/*也可以写作这样：</span><br><span class="hljs-comment">func f(x int,y int)(ret int)&#123;</span><br><span class="hljs-comment">ret=x+y</span><br><span class="hljs-comment">return</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure><p>特别注意可变长参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum2</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(x) <span class="hljs-comment">//x是一个切片，可以传多个参数 </span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x &#123;<br>sum = sum + v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言支持多个返回值</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><blockquote><p>有时候我们想在一个函数的末尾处调用一个统一的函数来进行一些收尾工作，但是如果函数分支众多，那么就有可能会疏忽大意导致在某个分支中没调用这个收尾函数。Go函数里提供了defer关键字，可以注册多个<strong>延迟调用</strong>，这些调用以<strong>先进后出</strong>的顺序在<strong>函数返回前执行</strong>。defer调用的执行时机是外层函数<strong>设置返回值之后</strong>，<strong>即将返回之前</strong>。</p><p>defer之后跟的是一个函数（并且这个函数要被调用），当 go 执行到一个 defer 时，不会立即执行 defer 后的语句，而是将 defer 后的函数以及相关的变量的拷贝压入到一个栈中, 然后继续执行函数下一个语句，defer在将调用压入栈前会先对函数的入参进行求值并拷贝一份。</p><p>在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行</p></blockquote><h4 id="defer介绍"><a href="#defer介绍" class="headerlink" title="defer介绍"></a>defer介绍</h4><p> 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferDemo</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;start&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;middle&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;哈哈哈&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;嘻嘻嘻&quot;</span>)<span class="hljs-comment">//先进后出的顺序执行</span><br>    fmt.Println(<span class="hljs-string">&quot;end&quot;</span>)<br>&#125;<span class="hljs-comment">//最后输出 start end 嘻嘻嘻 哈哈哈 middle</span><br></code></pre></td></tr></table></figure><p>defer多用于函数结束之前的释放资源（文件句柄、数据库连接、socket连接）</p><ul><li>Go语言中return不是原子操作，而是分为两步执行</li><li>函数中return语句的底层实现：返回值=x     -&gt;      RET指令</li><li>defer语句执行的时机：返回值=x     -&gt;        运行defer      -&gt;     RET指令</li></ul><h4 id="defer案例"><a href="#defer案例" class="headerlink" title="defer案例"></a>defer案例</h4><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<span class="hljs-comment">//修改的是返回值，不是返回值</span><br>&#125;()<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><span class="hljs-comment">//返回值=x</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<span class="hljs-comment">//修改x</span><br>&#125;()<br><span class="hljs-keyword">return</span> x<span class="hljs-comment">//返回值=y=x=5 说明事先声明了一个返回值变量</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x++<span class="hljs-comment">//改变的是函数中的副本</span><br>&#125;(x)<span class="hljs-comment">//返回值=x=5</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f1())<br>fmt.Println(f2())<br>fmt.Println(f3())<br>fmt.Println(f4())<br>&#125;<br><span class="hljs-comment">//输出 5 6 5 5</span><br></code></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言基础语法</title>
    <link href="/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>我们利用变量将这个数据的内存地址保存起来，以后可以直接通过这个变量就能找到内存上对应的数据了。</p></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量有不同的类型，对应存储不同的数据类型：</p><p>常见的有以下几种：</p><ul><li><p>bool: 布尔型的值<strong>只</strong>可以是常量 true 或者 false</p></li><li><p><code>int</code>：存放整数</p><p>​          八进制以0开头     十六进制用ox开头</p></li><li><p><code>float32/float64(默认)</code>: 存放小数，两者不能直接互相赋值</p></li><li><p><code>string</code>: 存放一串字符</p></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Go语言中变量必须先声明再使用</p><p>我们用关键字<code>var</code>用于声明变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> <br><span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span> = <span class="hljs-number">9</span> <span class="hljs-comment">//声明并赋值，不赋值的话默认是初始值</span><br><span class="hljs-keyword">var</span> a, b, c <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;I&#x27;m a&quot;</span>, <span class="hljs-string">&quot;I&#x27;m b&quot;</span>, <span class="hljs-string">&quot;I&#x27;m c&quot;</span> <span class="hljs-comment">//也可以同时声明多个变量并赋值</span><br><span class="hljs-keyword">var</span> x, y = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">//也可以不指定变量的类型直接赋值，此时go语言会根据你赋予的值自动判断变量类型</span><br>num := <span class="hljs-number">123</span><br>str := <span class="hljs-string">&quot;Lengyusen&quot;</span> <span class="hljs-comment">//也可以用短声明:=来自动判断类型，只能在函数内用(常用)</span><br><span class="hljs-keyword">var</span>(<br>    name <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int</span><br>)<span class="hljs-comment">//批量声明</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Go语言中非全局变量声明了必须使用，不使用就无法编译</li><li>Go语言中推荐使用驼峰命名 如：studentName</li><li>关键词不能当作变量名</li><li>同一个作用域变量不能重复声明</li></ul><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量，用一个下划线<code>_</code>表示。不占用命名空间，不会分配内存</p><h2 id="常量与iota"><a href="#常量与iota" class="headerlink" title="常量与iota"></a>常量与iota</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><span class="hljs-comment">//和var一样，多个常量也可以一起声明</span><br><span class="hljs-keyword">const</span> (<br>    pi = <span class="hljs-number">3.1415</span><br>    e = <span class="hljs-number">2.7182</span><br>)<br></code></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><blockquote><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中<strong>每新增一行</strong>常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p></blockquote><p>几个常见的<code>iota</code>示例:</p><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2        <span class="hljs-comment">//1</span><br>_<br>n4        <span class="hljs-comment">//3</span><br>)<br></code></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2 = <span class="hljs-number">100</span>  <span class="hljs-comment">//100</span><br>n3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span><br>n4        <span class="hljs-comment">//3</span><br>)<br><span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_  = <span class="hljs-literal">iota</span><br>KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<span class="hljs-comment">//将1的二进制表示向左移10位</span><br>MB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>GB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>TB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>PB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>)<br></code></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//1,2</span><br>c, d                      <span class="hljs-comment">//2,3</span><br>e, f                      <span class="hljs-comment">//3,4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h3><ul><li>%T 查看类型</li><li>%v 查看变量值(万能)</li><li>%d 查看十进制</li><li>%b 查看二进制</li><li>%o 查看八进制</li><li>%x 查看十六进制</li><li>%s 查看字符串</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中字符串用双引号包裹的，而单引号包裹的是字符。当定义一个多行字符串时，需要用到`符号(键盘上ESC下面的键)，但是对所有的转义字符均无效，文本会原样输出。</p><h4 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h4><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>​      要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;我爱Go语言&quot;</span><br> s2:= []<span class="hljs-keyword">rune</span>(s1)<span class="hljs-comment">//把字符串强制转化为rune切片</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;你&#x27;</span><br>fmt.Println(<span class="hljs-keyword">string</span>(runeS2))<span class="hljs-comment">//把rune切片强制转化为字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1结果为true时，执行此处代码  </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-comment">//当条件表达式2结果为true时，执行此处代码 </span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1，2结果为false时，执行此处代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环使Go语言中唯一的循环语句</p><pre><code> for循环的基本格式如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 初始语句;条件表达式;结束语句&#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><p>​    条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<span class="hljs-comment">//常用</span><br></code></pre></td></tr></table></figure><p>​    for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(i)<br>i++<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><p>​    无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。(一个break只能结束一层for循环)</li><li>for循环可以通过continue语句跳过此次循环。</li></ul><p>​    for range循环(键值循环)</p><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s:=<span class="hljs-string">&quot;Hello Leng&quot;</span><br><span class="hljs-keyword">for</span> i,v:=<span class="hljs-keyword">range</span> s&#123;<br>fmt.printf(<span class="hljs-string">&quot;%d %c\n&quot;</span>,i,v);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><p>​    使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo1</span><span class="hljs-params">()</span></span> &#123;<br>finger := <span class="hljs-number">3</span><br><span class="hljs-keyword">switch</span> finger &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>fmt.Println(<span class="hljs-string">&quot;大拇指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>fmt.Println(<span class="hljs-string">&quot;食指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>fmt.Println(<span class="hljs-string">&quot;中指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>fmt.Println(<span class="hljs-string">&quot;无名指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>fmt.Println(<span class="hljs-string">&quot;小拇指&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;无效的输入！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>​    一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testSwitch3</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := <span class="hljs-number">7</span>; n &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo4</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">30</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> age &lt; <span class="hljs-number">25</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好学习吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">25</span> &amp;&amp; age &lt; <span class="hljs-number">35</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好工作吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好享受吧&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;活着真好&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo5</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;a&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;b&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;c&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;c&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><blockquote><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。</p></blockquote><p> 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-comment">// 设置退出标签</span><br><span class="hljs-keyword">goto</span> breakTag<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v-%v\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-comment">// 标签</span><br>breakTag:<br>fmt.Println(<span class="hljs-string">&quot;结束for循环&quot;</span>)<br><span class="hljs-comment">//尽量少用</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p></blockquote><p>我们可以在给数组声明的同时赋值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [<span class="hljs-number">5</span>]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-string">&quot;Max&quot;</span>&#125; <span class="hljs-comment">//括号中初始化的元素个数不能大于数组的大小</span><br></code></pre></td></tr></table></figure><p>还可以不设置数组大小，Go 语言会自动根据元素的个数来设置数组的大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [...]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><blockquote><p>​        Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。切片是引用类型，不保存具体的值，都指向了底层的数组，如果修改切片，底层数组也会被修改。<strong>总而言之，切片就是一个框，框柱了一块连续的内存，切片属于引用类型，真正的数据都是保存在底层的数据之中的。</strong></p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name []T<br><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><span class="hljs-comment">//存放int类型数据的切片</span><br>s1=[]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h3><blockquote><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p></blockquote><ul><li>长度指的是切片中的元素个数</li><li>容量指的是切片对应的底层数组的元素个数，是底层数组从切片的第一个元素到最后一个元素的元素数量。</li></ul><h3 id="如何得到切片"><a href="#如何得到切片" class="headerlink" title="如何得到切片"></a>如何得到切片</h3><h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">a1:=&#123;...&#125;<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>&#125;<br>s1:=a1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7]基于一个数组切割，左包含右不包含</span><br>s2:=a1[:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7] =&gt;[0:4]</span><br>s3:=a1[<span class="hljs-number">3</span>:]<span class="hljs-comment">//[7 9 11 13] =&gt;[3:len(a1)]</span><br>s4:=a1[:]<span class="hljs-comment">//[1 3 5 7 9 11 13] =&gt;[0:len(a1)]</span><br></code></pre></td></tr></table></figure><h4 id="make-函数创造切片"><a href="#make-函数创造切片" class="headerlink" title="make( ) 函数创造切片"></a>make( ) 函数创造切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">//长度为2，容量为10</span><br>fmt.Println(a)      <span class="hljs-comment">//[0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">//2</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(a)) <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><h4 id="索引遍历"><a href="#索引遍历" class="headerlink" title="索引遍历"></a>索引遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>fmt.Println(i, s[i])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for-range遍历"><a href="#for-range遍历" class="headerlink" title="for  range遍历"></a>for  range遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Println(index, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="append-为切片追加元素"><a href="#append-为切片追加元素" class="headerlink" title="append( )为切片追加元素"></a>append( )为切片追加元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)        <span class="hljs-comment">// [1]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">// [1 2 3 4]</span><br>s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;  <br>s = <span class="hljs-built_in">append</span>(s, s2...)    <span class="hljs-comment">// [1 2 3 4 5 6 7] ...表示拆开</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>我们需要用原切片变量接收返回值，当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。</li><li>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</li><li>Go语言中无删除切片元素的方法，可以利用append()函数把不要的元素切掉，此时底层数组也会被修改</li><li>通过切片会改变底层数组，拷贝前后两个切片共享底层数组，对一个切片的修改会影响另一个切片的内容。而使用copy函数可以防止此情况。</li><li>可以使用sort.Ints(s[:])对切片进行排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2021/11/14/%E6%A0%91/"/>
    <url>/2021/11/14/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种分支结构，逻辑上是一对多，具有明显的递归特性。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>结点：包含一个数据元素和若干指向子树的分支</li><li>结点的度：结点上分支的个数</li><li>数的度：所有结点的最大分支数(结点度的最大值)</li><li>叶子节点：度为零的节点(末端)</li><li>双亲、孩子：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</li><li>森林：多棵树放在一起</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的每个结点至多只有两棵子树，且子树有左右之分，次序不能颠倒</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>满二叉树：除了最底层每个结点都有左右两个孩子</li><li>完全二叉树：满二叉树从最底层开始从右往左删除结点，满二叉树是特殊的完全二叉树</li></ul><h4 id="求完全二叉树的高度-h"><a href="#求完全二叉树的高度-h" class="headerlink" title="求完全二叉树的高度(h)"></a>求完全二叉树的高度(h)</h4><p>解此类问题重在分析结点与高度之间的关系</p><p>1.先分析满二叉树</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\F06C28DB02E9D1EBA4077DD627BC071A.jpg"></p><p>2.一般的完全二叉树</p><p>​     方法①：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\B520005BA6A661BC36A5CBFEB8260729.jpg"></p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\C79655C54222BEC83BCDD60A33FBEC0E.jpg"></p><p>​     方法②：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\14F0AF8E1F1DD63E69940BA566D8B5B7.jpg"></p><p>综上有两个公式(我偏向于记忆第一个，因为第一个更便于理解)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\56EB97FA5643D36AB5D969D00686A794.jpg"></p><p>​                （注：第一个是向下取整，第二个是向上取整）</p><h3 id="二叉树的一些性质"><a href="#二叉树的一些性质" class="headerlink" title="二叉树的一些性质"></a>二叉树的一些性质</h3><ul><li><p>总分支数=总结点数-1</p><p>   叶结点个数为N0</p><p>   单分枝结点个数为N1</p><p>   双分支结点个数为N2</p></li><li><p>总结点数=N0+N1+N2</p></li><li><p>总分支数=N1+2N2</p><p>   <strong>从而解得：N0=N2+1</strong></p><p>​                     <strong>叶子结点数=双分支节点数+1</strong></p><p>（普通树可用同样的方法类比：N0=1+N2+2N3+…+(m-1)Nm）</p></li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>把每个结点存入数组之中(但只对完全二叉树适用)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\6879E5CA54A244F6D9F13F05AD430235.jpg"></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>首先我们看看树的链式存储结构，用链表存储孩子结点的信息</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\31C74FFF31C21E4792E95A574724EBFF.jpg"></p><p>​     然后我们看二叉树，则可以表链表的长度取成二，但我们之所以用链表来存储数的信息，是因为链表方便存储不确定个数的信息。而我们现在已经知道了二叉树最多只有两个子树，所以我们可以直接定义两个指针来指向左右两个孩子。</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\1A256C933F8626A252683FEDD01EB861.jpg"></p><h3 id="数与二叉树的相互转换"><a href="#数与二叉树的相互转换" class="headerlink" title="数与二叉树的相互转换"></a>数与二叉树的相互转换</h3><p>​     方法：将数转化为二叉树：首先将每个结点与其兄弟结点相连，然后只留下最左边的连线，删去其他连线，最终形成的二叉树左边的连线是连的孩子，右边的连线是连的兄弟。而将二叉树转化为树则与上述操作相反即可，补全与双亲的连线，删去与兄弟的连线。下图是将树转化为二叉树的一个事例：</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\FB481DD3FAD88556E1850D77BCC54920.jpg" style="zoom:33%;"><h3 id="森林与二叉树的相互转换"><a href="#森林与二叉树的相互转换" class="headerlink" title="森林与二叉树的相互转换"></a>森林与二叉树的相互转换</h3><p>  方法：森林转化为二叉树：首先将森林中的每棵数都先转化为二叉树，则每棵二叉树根节点的左边接的是子树，右边为空，然后就可以让右边接下一棵树的根节点。而将二叉树转换为森林即实现相反操作。</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\0163938A33B279A3770AB24ED6D120FB.jpg" style="zoom: 25%;"><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>层次遍历(广度优先遍历)：从上至下，从左至右</p></li><li><p><em><strong>前序遍历：根-左-右</strong></em></p></li><li><p><em><strong>中序遍历：左-根-右</strong></em></p></li><li><p><em><strong>后序遍历：左-右-根</strong></em></p></li></ul><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\7B0ACC7E9692F5401BB179C67F32438C.jpg"></p><p>​        树的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\2FAE304F42ECD1CA3B8DF1C394672E85.jpg"></p><p>​        森林的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\3C551A4C1BE1291709BC8F848781898A.jpg"></p><h4 id="递归函数基础"><a href="#递归函数基础" class="headerlink" title="递归函数基础"></a>递归函数基础</h4><p>函数自己调用自己</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\EEC46EE6479E306BFF6318E5232F51BD.jpg"></p><h4 id="二叉树遍历以代码实现"><a href="#二叉树遍历以代码实现" class="headerlink" title="二叉树遍历以代码实现"></a>二叉树遍历以代码实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
