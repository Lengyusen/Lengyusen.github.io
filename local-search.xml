<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>接口 包 文件操作</title>
    <link href="/2021/11/20/%E6%8E%A5%E5%8F%A3%20%E5%8C%85%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/11/20/%E6%8E%A5%E5%8F%A3%20%E5%8C%85%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>我们设想一下：</p><ul><li>一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</li><li>三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</li><li>销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</li><li>手机是商品类，电子产品也是商品类，难道我们要在手机和电子产品结构体中都加上商品结构体吗</li></ul><p>所以我们在编程中会遇到一下问题：</p><ul><li>我不关心一个变量是什么类型，我只关心能调用它的什么方法</li></ul><blockquote><p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种<strong>抽象的类型</strong>，它规定了变量有哪些方法。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p></blockquote><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>Go语言提倡面向接口编程。</p><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 接口类型名 <span class="hljs-keyword">interface</span>&#123;<br>    方法名<span class="hljs-number">1</span>( 参数列表<span class="hljs-number">1</span> ) 返回值列表<span class="hljs-number">1</span><br>    方法名<span class="hljs-number">2</span>( 参数列表<span class="hljs-number">2</span> ) 返回值列表<span class="hljs-number">2</span><br>    …<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子，不管是什么类型的车，都可以驾驶：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-comment">//定义一个car接口类型  不管是什么结构体 只要有run方法都能是car类型</span><br><span class="hljs-keyword">type</span> car <span class="hljs-keyword">interface</span>&#123;<br>   run()<br>&#125;<br><br><span class="hljs-keyword">type</span> falali <span class="hljs-keyword">struct</span>&#123;<br>   brand <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f falali)</span><span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;%s速度70迈\n&quot;</span>,f.brand)<br>&#125;<br><br><span class="hljs-keyword">type</span> baoshijie <span class="hljs-keyword">struct</span>&#123;<br>   brand <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b baoshijie)</span><span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;%s速度70迈\n&quot;</span>,b.brand)<br>&#125;<br><br><span class="hljs-comment">//drive函数接收一个car类型的变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">drive</span><span class="hljs-params">(c car)</span></span>&#123;<br>   c.run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">var</span> f1 = falali&#123;<br>      brand:<span class="hljs-string">&quot;法拉利&quot;</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> b1 = baoshijie&#123;<br>   brand:<span class="hljs-string">&quot;保时捷&quot;</span>,<br>   &#125;<br>   drive(f1)<br>   drive(b1)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>一个变量如果实现了接口中规定的所有方法，那么这个变量就实现了这个接口，可以称为这个接口类型的变量。</p><ul><li>多个类型可以实现同一个接口</li><li>一个类型可以实现多个接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span>&#123;<br>    move()<br>    eat(<span class="hljs-keyword">string</span>)<br>&#125;<br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-keyword">string</span><br>    feet <span class="hljs-keyword">int8</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用值接收者实现了接口的所有方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;走猫步......&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">(food <span class="hljs-keyword">string</span>)</span></span>&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;猫吃%s...\n&quot;</span>,food)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> a1,a2 animal<br>c1:=cat&#123;<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">4</span>&#125;<span class="hljs-comment">//cat</span><br>c2:=&amp;cat&#123;<span class="hljs-string">&quot;假老练&quot;</span>,<span class="hljs-number">4</span>&#125;<span class="hljs-comment">//*cat</span><br>a1=c1<br>a2=c2<br>fmt.Println(a1)<br>fmt.Println(a2)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用指针接收者实现了接口的所有方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cat)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;走猫步......&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">(food <span class="hljs-keyword">string</span>)</span></span>&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;猫吃%s...\n&quot;</span>,food)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> a1,a2 animal<br>c1:=cat&#123;<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">4</span>&#125;<br>c2:=&amp;cat&#123;<span class="hljs-string">&quot;假老练&quot;</span>,<span class="hljs-number">4</span>&#125;<br>a1=&amp;c1<br>a2=c2<br>fmt.Println(a1)<br>fmt.Println(a2)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用值接收者和使用指针接收者实现接口的区别：</p><ul><li>使用值接收者实现接口，结构体类型和结构体指针类型的变量都能存</li><li>指针接收者实现接口只能存结构体指针类型的变量</li></ul><h3 id="接口的嵌套"><a href="#接口的嵌套" class="headerlink" title="接口的嵌套"></a>接口的嵌套</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span>&#123;<br>   mover<br>   eater<br>&#125;<br><span class="hljs-keyword">type</span> mover <span class="hljs-keyword">interface</span>&#123;<br>   move()<br>&#125;<br><span class="hljs-keyword">type</span> eater <span class="hljs-keyword">interface</span>&#123;<br>   eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span>&#123;<br>   name <span class="hljs-keyword">string</span><br>   feet <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;走猫步......&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">(food <span class="hljs-keyword">string</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;猫吃%s...\n&quot;</span>,food)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">var</span> c1 cat<br>   c1.name=<span class="hljs-string">&quot;假老练&quot;</span><br>   c1.feet=<span class="hljs-number">4</span><br>   c1.move()<br>   c1.eat(<span class="hljs-string">&quot;fish&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>没有必要起名字，通常定义成下面这样的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-comment">//空接口</span><br></code></pre></td></tr></table></figure><p>所有类型都实现了空接口，也就是任意类型的变量都能保存到空接口中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>预备知识</title>
    <link href="/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/11/17/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>指针就是地址，地址就是指针</li><li>指针变量是存放内存单元地址的变量</li><li>指针的本质是一个操作受限的非负整数</li></ul><h2 id="基本类型的指针"><a href="#基本类型的指针" class="headerlink" title="基本类型的指针"></a>基本类型的指针</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span>* p=&amp;i;<span class="hljs-comment">//等价于 int *p; p=&amp;i;</span><br></code></pre></td></tr></table></figure><p>详解这两步操作：</p><ol><li>p存放了i的地址，所以我们说p指向了i</li><li>p和i是完全不同的两个变量，修改其中任何一个变量的值都不会改变另外一个</li><li>p指向i，*p就是i变量本身。更形象的说，所有出现 *p的地方都可以换成i，同理，所有出现i的地方都可以 *p</li></ol><p>总结：</p><ol><li><p>如果一个指针变量(假定为p)存放了某个普通变量(假定为i)的地址，那我们可以说:”p指向了I“，但p与i是两个不同的变量，修改p的值不影响i的值，修改i的值不影响p的值。</p></li><li><p>*p等价于i 或者说 *p可以在任何地方互换</p></li><li><p>如果一个变量指针指向了某个普通变量，则*指针变量 就完全等价于该普通变量</p></li></ol><h2 id="指针和数组之间的关系"><a href="#指针和数组之间的关系" class="headerlink" title="指针和数组之间的关系"></a>指针和数组之间的关系</h2><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h1 id="动态内存的分配和释放"><a href="#动态内存的分配和释放" class="headerlink" title="动态内存的分配和释放"></a>动态内存的分配和释放</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言进阶语法</title>
    <link href="/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/17/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言进阶语法"><a href="#go语言进阶语法" class="headerlink" title="go语言进阶语法"></a>go语言进阶语法</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言中不存在指针操作，只需要记住两个符号：&amp;取地址，*根据地址取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类似C语言实现指针传值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify2</span><span class="hljs-params">(x *<span class="hljs-keyword">int</span>)</span></span> &#123;<br>*x = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">10</span><br>modify1(a)<br>fmt.Println(a) <span class="hljs-comment">// 10</span><br>modify2(&amp;a)<br>fmt.Println(a) <span class="hljs-comment">// 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>首先我们看个代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>b[<span class="hljs-string">&quot;重邮&quot;</span>] = CQUPT<br>fmt.Println(b)<span class="hljs-comment">//无法运行</span><br></code></pre></td></tr></table></figure><p>​      在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><blockquote><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>*a = <span class="hljs-number">10</span><br>fmt.Println(*a)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><blockquote><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><br>s1= <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>fmt.Println(s1)<br></code></pre></td></tr></table></figure><h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><ol><li>make和new都是用来申请内存的</li><li>new很少用，一般用来给基本数据类型申请内存，int，返回的是对应指针*int</li><li>make是用来给slice、map、chan申请内存的，make函数返回的是类型本身</li></ol><h2 id="字典map——用时间换空间"><a href="#字典map——用时间换空间" class="headerlink" title="字典map——用时间换空间"></a>字典map——用时间换空间</h2><p>基本上所有的编程语言都自带一种数据结构，它主要提供一个快速的查找，插入，删除，具备与存储体量无关的O（1）的性能，并且支持key上面的唯一性。go也原生提供了一个类似的数据类型，就叫做map。</p><p>关键点：</p><ol><li>map 是由 <code>key-value</code> 对（键值对）组成的</li><li>key 只会出现一次。</li><li>Go语言中的map是引用类型，必须初始化才能使用</li></ol><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// 声明一个key和string是string类型的map</span><br><span class="hljs-keyword">var</span> m1 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<span class="hljs-comment">//声明+初始化-在内存中开辟空间</span><br><span class="hljs-keyword">var</span> m3 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span> = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;lastname&quot;</span>: <span class="hljs-string">&quot;Leng&quot;</span>, <span class="hljs-string">&quot;firstname&quot;</span>: <span class="hljs-string">&quot;yusen&quot;</span>&#125;<span class="hljs-comment">//声明+初始化+赋值,也可以通过索引对相应的值进行赋值 m3[&quot;lastname&quot;]=&quot;re&quot;</span><br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>类似数组和切片， map 的读取类似 slice，通过 key 来操作，只是 slice 的index （下标或者叫索引）只能是int类型。</p></blockquote><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := <span class="hljs-keyword">map</span>[key]<span class="hljs-comment">//约定俗成用ok接收返回的布尔值</span><br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">scoreMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>scoreMap[<span class="hljs-string">&quot;张三&quot;</span>] = <span class="hljs-number">90</span><br>scoreMap[<span class="hljs-string">&quot;小明&quot;</span>] = <span class="hljs-number">100</span><br><span class="hljs-comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br>v, ok := scoreMap[<span class="hljs-string">&quot;张三&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(v)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;查无此人&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h4><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k,v)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for k:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(k)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for —_,v:=range s&#123;<br>fmt.<span class="hljs-built_in">Println</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, key)<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是把一段逻辑抽象出来封装到一个函数中，使代码更简洁</p><p>具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(参数)</span><span class="hljs-params">(返回值)</span></span>&#123;<br>    函数体<br>&#125;<br><span class="hljs-comment">//返回值参数可命名，也可不命名，命名的返回值相当于在函数中声明变量</span><br></code></pre></td></tr></table></figure><p>比如带参数和返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>,y <span class="hljs-keyword">int</span>)</span><span class="hljs-title">int</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-comment">/*也可以写作这样：</span><br><span class="hljs-comment">func f(x int,y int)(ret int)&#123;</span><br><span class="hljs-comment">ret=x+y</span><br><span class="hljs-comment">return</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure><p>特别注意可变长参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum2</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(x) <span class="hljs-comment">//x是一个切片，可以传多个参数 </span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x &#123;<br>sum = sum + v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言支持多个返回值</p><h3 id="defer——收尾工作执行者"><a href="#defer——收尾工作执行者" class="headerlink" title="defer——收尾工作执行者"></a>defer——收尾工作执行者</h3><blockquote><p>有时候我们想在一个函数的末尾处调用一个统一的函数来进行一些收尾工作，但是如果函数分支众多，那么就有可能会疏忽大意导致在某个分支中没调用这个收尾函数。Go函数里提供了defer关键字，可以注册多个<strong>延迟调用</strong>，这些调用以<strong>先进后出</strong>的顺序在<strong>函数返回前执行</strong>。defer调用的执行时机是外层函数<strong>设置返回值之后</strong>，<strong>即将返回之前</strong>。</p><p>defer之后跟的是一个函数（并且这个函数要被调用），当 go 执行到一个 defer 时，不会立即执行 defer 后的语句，而是将 defer 后的函数以及相关的变量的拷贝压入到一个栈中, 然后继续执行函数下一个语句，defer在将调用压入栈前会先对函数的入参进行求值并拷贝一份。</p><p>在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行</p></blockquote><h4 id="defer介绍"><a href="#defer介绍" class="headerlink" title="defer介绍"></a>defer介绍</h4><p> 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferDemo</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;start&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;middle&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;哈哈哈&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;嘻嘻嘻&quot;</span>)<span class="hljs-comment">//先进后出的顺序执行</span><br>    fmt.Println(<span class="hljs-string">&quot;end&quot;</span>)<br>&#125;<span class="hljs-comment">//最后输出 start end 嘻嘻嘻 哈哈哈 middle</span><br></code></pre></td></tr></table></figure><p>defer多用于函数结束之前的释放资源（文件句柄、数据库连接、socket连接）</p><ul><li>Go语言中return不是原子操作，而是分为两步执行</li><li>函数中return语句的底层实现：返回值=x     -&gt;      RET指令</li><li>defer语句执行的时机：返回值=x     -&gt;        运行defer      -&gt;     RET指令</li></ul><h4 id="defer案例"><a href="#defer案例" class="headerlink" title="defer案例"></a>defer案例</h4><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<span class="hljs-comment">//修改的是返回值，不是返回值</span><br>&#125;()<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><span class="hljs-comment">//返回值=x</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<span class="hljs-comment">//修改x</span><br>&#125;()<br><span class="hljs-keyword">return</span> x<span class="hljs-comment">//返回值=y=x=5 说明事先声明了一个返回值变量</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x++<span class="hljs-comment">//改变的是函数中的副本</span><br>&#125;(x)<span class="hljs-comment">//返回值=x=5</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f1())<br>fmt.Println(f2())<br>fmt.Println(f3())<br>fmt.Println(f4())<br>&#125;<br><span class="hljs-comment">//输出 5 6 5 5</span><br></code></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>全局作用域</li><li>函数作用域：先在函数内部找变量，找不到往外层找：函数内部变量外层访问不到</li><li>代码块作用域</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>, op <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>) <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> op(x, y)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ret2 := calc(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, add)<br>fmt.Println(ret2) <span class="hljs-comment">//30</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br><span class="hljs-keyword">return</span> add, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br><span class="hljs-keyword">return</span> sub, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>err := errors.New(<span class="hljs-string">&quot;无法识别的操作符&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数——没有名字的临时工"><a href="#匿名函数——没有名字的临时工" class="headerlink" title="匿名函数——没有名字的临时工"></a>匿名函数——没有名字的临时工</h3><blockquote><p>匿名函数，顾名思义就是没有名字（准确来说是没有函数名字）的函数，它的定义往往是在一个函数里面。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//函数内部没有办法声明带名字的函数，我们可以定义匿名函数</span><br>    f1:=<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x，y <span class="hljs-keyword">int</span>)</span>｛</span><br>    fmt.Println(x+y)<br>    ｝<br>    f1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)<br>｝<br>    <br>    <span class="hljs-comment">//如果只是调用一次的函数，还可以简写为立即执行函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x，y <span class="hljs-keyword">int</span>)</span>｛</span><br>fmt.Println(x+y)<br>｝(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包=函数+外部变量的引用</p><blockquote><p>闭包是携带状态的函数，它是将函数内部和函数外部连接起来的桥梁。通过闭包，我们可以读取函数内部的变量。闭包能够引用其作用域上部的变量并进行修改，被捕获到闭包中的变量将随着闭包的生命周期一直存在，函数本身是不存储信息的，但是闭包中的变量使闭包本身具备了存储信息的能力。另外，在项目中<strong>不要乱用闭包</strong>，因为这种操作用处不大。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>, <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>)</span> &#123;<br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>base += i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><br>sub := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>base -= i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><span class="hljs-keyword">return</span> add, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1, f2 := calc(<span class="hljs-number">10</span>)<br>fmt.Println(f1(<span class="hljs-number">1</span>), f2(<span class="hljs-number">2</span>)) <span class="hljs-comment">//11 9</span><br>fmt.Println(f1(<span class="hljs-number">3</span>), f2(<span class="hljs-number">4</span>)) <span class="hljs-comment">//12 8</span><br>fmt.Println(f1(<span class="hljs-number">5</span>), f2(<span class="hljs-number">6</span>)) <span class="hljs-comment">//13 7</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="panic-amp-recover—我叫程序，我感到恐慌"><a href="#panic-amp-recover—我叫程序，我感到恐慌" class="headerlink" title="panic&amp;recover—我叫程序，我感到恐慌"></a>panic&amp;recover—我叫程序，我感到恐慌</h3><p>panic和recover是两个内置函数，这两个内置函数用来处理Go的运行错误(runtime errors)</p><ul><li><p> panic用来主动抛出错误 </p></li><li><p> recover用来捕获panic抛出的错误 </p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcA</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcB</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span><br>fmt.Println(err)<br>fmt.Println(<span class="hljs-string">&quot;释放数据库连接......&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;出现严重错误&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcC</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;c&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>funcA()<br>funcB()<br>funcC()<br>&#125;<br><span class="hljs-comment">/*输出</span><br><span class="hljs-comment">a</span><br><span class="hljs-comment">出现严重错误</span><br><span class="hljs-comment">释放数据库连接......</span><br><span class="hljs-comment">c*/</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h3 id="递归——自己调用自己"><a href="#递归——自己调用自己" class="headerlink" title="递归——自己调用自己"></a>递归——自己调用自己</h3><p>递归一定要有一个明确退出的条件，适合处理那种问题相同、问题规模越来越小的场景。</p><p>计算阶乘：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-title">uint64</span></span>&#123;<br>    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> n*f(n<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上台阶问题：n个台阶，一次可以走一步，也可以走两步，有多少种走法。    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">taijie</span><span class="hljs-params">(n <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-title">uint64</span></span>&#123;<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>&#123;<br>        <span class="hljs-comment">//只有一个台阶就只有一种走法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n==<span class="hljs-number">2</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    reutrn taijie(n<span class="hljs-number">-1</span>)+taijie(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数版学生管理系统"><a href="#函数版学生管理系统" class="headerlink" title="函数版学生管理系统"></a>函数版学生管理系统</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   函数版学生管理系统</span><br><span class="hljs-comment">   写一个系统能够查看、新增学生、删除学生</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span>(<br>   allStudent <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]*student<span class="hljs-comment">//变量声明</span><br>)<br><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span>&#123;<br>   id <span class="hljs-keyword">int64</span><br>   name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStudent</span><span class="hljs-params">(id <span class="hljs-keyword">int64</span>,name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">student</span></span>&#123;<span class="hljs-comment">//student类型的构造函数</span><br>   <span class="hljs-keyword">return</span> &amp;student&#123;<br>      id:id,<br>      name:name,<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showAllStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//把所以学生都打印出来</span><br>   <span class="hljs-keyword">for</span> k,v:=<span class="hljs-keyword">range</span> allStudent&#123;<br>      fmt.Printf(<span class="hljs-string">&quot;学号:%d,姓名:%s\n&quot;</span>,k,v.name)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//向allStudent中添加一个新的学生</span><br>   <span class="hljs-comment">//1.创建一个新学生</span><br>   <span class="hljs-keyword">var</span>(<br>      id <span class="hljs-keyword">int64</span><br>      name <span class="hljs-keyword">string</span><br>   )<br>   <span class="hljs-comment">//1.1 获取用户的输入</span><br>   fmt.Print(<span class="hljs-string">&quot;请输入学生的学号：&quot;</span>)<br>   fmt.Scanln(&amp;id)<br>   fmt.Print(<span class="hljs-string">&quot;请输入学生的姓名：&quot;</span>)<br>   fmt.Scanln(&amp;name)<br>   <span class="hljs-comment">//1.2创造一个2学生</span><br>   newStu :=newStudent(id,name)<br>   <span class="hljs-comment">//2.追加到allStudent这个map中</span><br>   allStudent[id] = newStu<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//1.请用户输入要删除的学生学号</span><br>   <span class="hljs-keyword">var</span> (<br>      deleteId <span class="hljs-keyword">int64</span><br>   )<br>   fmt.Println(<span class="hljs-string">&quot;请输入学生的学号：&quot;</span>)<br>   fmt.Scanln(&amp;deleteId)<br>   <span class="hljs-comment">//2.去allStudent这个map中根据学生学号删除对应键值对</span><br>   <span class="hljs-built_in">delete</span>(allStudent,deleteId)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   allStudent = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]*student,<span class="hljs-number">48</span>)<span class="hljs-comment">//初始化-开辟空间</span><br>   <span class="hljs-keyword">for</span>&#123;<br>      <span class="hljs-comment">//1.打印菜单</span><br>      fmt.Println(<span class="hljs-string">&quot;欢迎使用学生管理系统！&quot;</span>)<br>      fmt.Println(<span class="hljs-string">`</span><br><span class="hljs-string">         1.查看所有学生</span><br><span class="hljs-string">         2.新增学生</span><br><span class="hljs-string">         3.删除学生</span><br><span class="hljs-string">         4.退出</span><br><span class="hljs-string">      `</span>)<br>      fmt.Println(<span class="hljs-string">&quot;请输入你的选择:&quot;</span>)<br>      <span class="hljs-comment">//2.等待用户选择要干什么</span><br>      <span class="hljs-keyword">var</span> choice <span class="hljs-keyword">int</span><br>      fmt.Scanln(&amp;choice)<br>      fmt.Printf(<span class="hljs-string">&quot;你选择了%d这个选项\n&quot;</span>,choice)<br>      <span class="hljs-comment">//3.执行对应的函数</span><br>      <span class="hljs-keyword">switch</span> choice&#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         showAllStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         addStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         deleteStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         os.Exit(<span class="hljs-number">1</span>)<span class="hljs-comment">//退出</span><br>      <span class="hljs-keyword">default</span>:<br>         fmt.Println(<span class="hljs-string">&quot;输入错误！&quot;</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一种数据类型，一种我们自己造的可以保存多个维度的数据。</p><h3 id="类型别名与自定义类型"><a href="#类型别名与自定义类型" class="headerlink" title="类型别名与自定义类型"></a>类型别名与自定义类型</h3><p> Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//将MyInt定义为int类型</span><br><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//我们之前见过的rune和byte就是类型别名，他们的定义如下：</span><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">byte</span> = <span class="hljs-keyword">uint8</span><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">rune</span> = <span class="hljs-keyword">int32</span><br></code></pre></td></tr></table></figure><p>二者的区别：</p><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">type</span> NewInt <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">//类型别名</span><br><span class="hljs-keyword">type</span> MyInt = <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a NewInt<br><span class="hljs-keyword">var</span> b MyInt<br><br>fmt.Printf(<span class="hljs-string">&quot;type of a:%T\n&quot;</span>, a) <span class="hljs-comment">//type of a:main.NewInt</span><br>fmt.Printf(<span class="hljs-string">&quot;type of b:%T\n&quot;</span>, b) <span class="hljs-comment">//type of b:int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> name <span class="hljs-keyword">struct</span>&#123;<br>    field1 type1<br>    field2 type2<br>    field3 type3<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>city <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>    hobby []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p person<br>p.name = <span class="hljs-string">&quot;Leng&quot;</span><br>p.city = <span class="hljs-string">&quot;重庆&quot;</span><br>p.age = <span class="hljs-number">18</span><br>    p.hobby = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;Go语言&quot;</span>,<span class="hljs-string">&quot;C语言&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;p1=%v\n&quot;</span>, p1)  <span class="hljs-comment">//p1=&#123;Leng 重庆 18 [Go语言 C语言]&#125;</span><br>    fmt.Printf(<span class="hljs-string">&quot;p1=%#v\n&quot;</span>, p1) <span class="hljs-comment">//p1=main.person&#123;name:&quot;Leng&quot;, city:&quot;重庆&quot;, age:18,hobby:[Go语言 C语言]&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>匿名结构体多用于一些临时的场景，放于main函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">struct</span>&#123;<br>    x <span class="hljs-keyword">string</span><br>    y iant<br>&#125;<br>s.x=<span class="hljs-string">&quot;hello&quot;</span><br>s.y=<span class="hljs-string">&quot;100&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go语言中函数参数永远是拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x person)</span></span>&#123;<br>    x.gender=<span class="hljs-string">&quot;女&quot;</span><span class="hljs-comment">//修改的是副本的gender</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(x *person)</span></span>&#123;<br>    (*x).gender=<span class="hljs-string">&quot;女&quot;</span><span class="hljs-comment">//根据内存地址找到那个原变量，修改的就是原来的变量</span><br>    <span class="hljs-comment">//语法糖：可以直接写 x.gender=&quot;女&quot;——自动根据指针找对应的变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> p person<br>    p.name = <span class="hljs-string">&quot;小猪佩奇&quot;</span><br>    p.gender = <span class="hljs-string">&quot;男&quot;</span><br>    f(p)<br>    fmt.Println(p.gender)<span class="hljs-comment">//男</span><br>    f2(&amp;p)<br>    fmt.Println(p.gender)<span class="hljs-comment">//女</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">p3 := &amp;person&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, p3)     <span class="hljs-comment">//*main.person</span><br>fmt.Printf(<span class="hljs-string">&quot;p3=%#v\n&quot;</span>, p3) <span class="hljs-comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br>p3.name = <span class="hljs-string">&quot;七米&quot;</span><br>p3.age = <span class="hljs-number">30</span><br>p3.city = <span class="hljs-string">&quot;成都&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;p3=%#v\n&quot;</span>, p3) <span class="hljs-comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span><br></code></pre></td></tr></table></figure><h3 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h3><h4 id="单个初始化"><a href="#单个初始化" class="headerlink" title="单个初始化"></a>单个初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>city <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p1 person<br>p1.name = <span class="hljs-string">&quot;小猪佩奇&quot;</span><br>   p1.city = <span class="hljs-string">&quot;重庆&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>city <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> p1 person&#123;<br>        name:<span class="hljs-string">&quot;小猪佩奇&quot;</span><br>        city:<span class="hljs-string">&quot;北京&quot;</span><br>        age:<span class="hljs-number">18</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">p6 := &amp;person&#123;<br>name: <span class="hljs-string">&quot;小王子&quot;</span>,<br>city: <span class="hljs-string">&quot;北京&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;p6=%#v\n&quot;</span>, p6) <span class="hljs-comment">//p6=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></code></pre></td></tr></table></figure><h4 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>city <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> p1 person&#123;<br>        <span class="hljs-string">&quot;小猪佩奇&quot;</span>,<br>        <span class="hljs-string">&quot;北京&quot;</span>,<br>        <span class="hljs-number">18</span>,<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">必须初始化结构体的所有字段。</span><br><span class="hljs-comment">初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="hljs-comment">该方式不能和键值初始化方式混用。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h4><p>如果我们对一个结构体需要进行多次初始化，我们就可以构造一个函数实现。返回值是结构体还是结构体指针都可以，但当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销，因为结构体是指类型，赋值的时候是拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>,age <span class="hljs-keyword">int</span>)</span>*<span class="hljs-title">person</span></span>&#123;<br>    <span class="hljs-keyword">return</span> &amp;person&#123;<br>        name:name,<br>        age:age,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p1:=newPerson(<span class="hljs-string">&quot;佩奇&quot;</span>,<span class="hljs-number">18</span>)<br>    p2:=newPerson(<span class="hljs-string">&quot;乔治&quot;</span>,<span class="hljs-number">14</span>)<br>    fmt.Println(p1,p2 )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p> Go语言中的方法是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者。接受者表示的是调用该方法的具体类型变量，多用类型名首字母小写表示。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(接收者变量 接收者类型)</span> 方法名<span class="hljs-params">(参数列表)</span> <span class="hljs-params">(返回参数)</span></span> &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子，构造一个人的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-keyword">string</span><br>age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>,age <span class="hljs-keyword">int</span>)</span><span class="hljs-title">person</span></span>&#123;<br><span class="hljs-keyword">return</span> person&#123;<br>name:name,<br>age:age,<br>&#125;<br>&#125;<br><span class="hljs-comment">//构造方法</span><br><span class="hljs-comment">//使用值接收者：传拷贝进去</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p person)</span><span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s:Hello Word!&quot;</span>,p.name)<br>&#125;<br><span class="hljs-comment">//使用指针接收者：传内存地址进去</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *person)</span> <span class="hljs-title">birthday</span><span class="hljs-params">()</span></span>&#123;<br>p.age++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>d1:=newPerson(<span class="hljs-string">&quot;佩奇&quot;</span>,<span class="hljs-number">18</span>)<br>d1.hello()<br>d1.birthday()<br>    fmt.Println()<br>fmt.Println(d1.age)<br>&#125;<br><span class="hljs-comment">/*佩奇:Hello Word!</span><br><span class="hljs-comment">  19*/</span><br></code></pre></td></tr></table></figure><p>什么时候应该使用指针类型接收者：</p><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><p>给一个自定义类型添加方法(不能给别的包里面的类型添加方法，只能给自己的类型添加方法)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myInt)</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;我是一个int&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    m:=myInt(<span class="hljs-number">100</span>)<span class="hljs-comment">//强制类型转换，把整型100转换成myInt</span><br>    m.hello()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>适用于字段比较少也比较简单的场景，不常用！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">string</span><br><span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;<br><span class="hljs-string">&quot;leng&quot;</span>,<br><span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, p1)        <br>fmt.Println(p1.<span class="hljs-keyword">string</span>, p1.<span class="hljs-keyword">int</span>) <br></code></pre></td></tr></table></figure><p><strong>注意：</strong>这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Address 地址结构体</span><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Province <span class="hljs-keyword">string</span><br>City     <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">//User 用户结构体</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span><br>Gender  <span class="hljs-keyword">string</span><br>Address Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user1 := User&#123;<br>Name:   <span class="hljs-string">&quot;小王子&quot;</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Address: Address&#123;<br>Province: <span class="hljs-string">&quot;山东&quot;</span>,<br>City:     <span class="hljs-string">&quot;威海&quot;</span>,<br>&#125;,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;user1=%#v\n&quot;</span>,user1)<span class="hljs-comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体模拟实现继承"><a href="#结构体模拟实现继承" class="headerlink" title="结构体模拟实现继承"></a>结构体模拟实现继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Animal 动物</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动！\n&quot;</span>, a.name)<br>&#125;<br><br><span class="hljs-comment">//Dog 狗</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Feet    <span class="hljs-keyword">int8</span><br>Animal <span class="hljs-comment">//通过嵌套匿名结构体实现继承 -Animal有的方法Dog也有</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">wang</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d1 := Dog&#123;<br>Feet: <span class="hljs-number">4</span>,<br>Animal: Animal&#123; <br>name: <span class="hljs-string">&quot;乐乐&quot;</span>,<br>&#125;,<br>&#125;<br>d1.wang() <span class="hljs-comment">//乐乐会汪汪汪~</span><br>d1.move() <span class="hljs-comment">//乐乐会动！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体版学生管理系统"><a href="#结构体版学生管理系统" class="headerlink" title="结构体版学生管理系统"></a>结构体版学生管理系统</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   函数版学生管理系统</span><br><span class="hljs-comment">   写一个系统能够查看、新增学生、删除学生</span><br><span class="hljs-comment">   保存了一些数据 =&gt;结构体的字段  ;三个功能  =&gt;结构体的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> smr studentMgr<br><br><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span>&#123;<br>   id <span class="hljs-keyword">int64</span><br>   name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">//造一个学生的管理者</span><br><span class="hljs-keyword">type</span> studentMgr <span class="hljs-keyword">struct</span>&#123;<br>   allStudent <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]student<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s studentMgr)</span> <span class="hljs-title">showAllStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//把所有学生都打印出来 stu是具体每一个学生</span><br>   <span class="hljs-keyword">for</span> _,stu:=<span class="hljs-keyword">range</span> s.allStudent&#123;<br>      fmt.Printf(<span class="hljs-string">&quot;学号:%d,姓名:%s\n&quot;</span>,stu.id,stu.name)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s studentMgr)</span> <span class="hljs-title">addStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//向allStudent中添加一个新的学生</span><br>   <span class="hljs-comment">//1.创建一个新学生</span><br>   <span class="hljs-keyword">var</span>(<br>      stuID <span class="hljs-keyword">int64</span><br>      stuName <span class="hljs-keyword">string</span><br>   )<br>   <span class="hljs-comment">//1.1 获取用户的输入</span><br>   fmt.Print(<span class="hljs-string">&quot;请输入学生的学号：&quot;</span>)<br>   fmt.Scanln(&amp;stuID)<br>   fmt.Print(<span class="hljs-string">&quot;请输入学生的姓名：&quot;</span>)<br>   fmt.Scanln(&amp;stuName)<br>   <span class="hljs-comment">//1.2创造一个学生</span><br>   newStu :=student&#123;<br>      id:stuID,<br>      name:stuName,<br>   &#125;<br>   <span class="hljs-comment">//2.追加到allStudent这个map中</span><br>   s.allStudent[newStu.id] = newStu<br>   fmt.Println(<span class="hljs-string">&quot;添加成功！&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s studentMgr)</span> <span class="hljs-title">editStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">//1.获取用户输入的学号</span><br>   <span class="hljs-keyword">var</span> stuID <span class="hljs-keyword">int64</span><br>   fmt.Println(<span class="hljs-string">&quot;请输入学号：&quot;</span>)<br>   fmt.Scanln(&amp;stuID)<br>   <span class="hljs-comment">//2.展示该学号对应的学生信息，如果没有提示查无此人</span><br>   stuObj,ok:=s.allStudent[stuID]<br>   <span class="hljs-keyword">if</span> !ok&#123;<br>      fmt.Println(<span class="hljs-string">&quot;查无此人&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   fmt.Printf(<span class="hljs-string">&quot;你要修改的学生信息如下：学号：%d,姓名：%s\n&quot;</span>,stuObj.id,stuObj.name)<br>   <span class="hljs-comment">//3.请输入修改后的学生名</span><br>   fmt.Print(<span class="hljs-string">&quot;请输入学生的新名字&quot;</span>)<br>   <span class="hljs-keyword">var</span> newName <span class="hljs-keyword">string</span><br>   fmt.Scanln(&amp;newName)<br>   <span class="hljs-comment">//4.更新学生的姓名</span><br>   stuObj.name=newName<br>   s.allStudent[stuID]=stuObj<span class="hljs-comment">//更新map中的学生</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s studentMgr)</span> <span class="hljs-title">deleteStudent</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">var</span> stuID <span class="hljs-keyword">int64</span><br>   <span class="hljs-comment">//1.请用户输入要删除的学生学号</span><br>   fmt.Println(<span class="hljs-string">&quot;请输入学号：&quot;</span>)<br>   fmt.Scanln(&amp;stuID)<br>   <span class="hljs-comment">//2.去map找有没有这个学生，如果没有提示查无此人</span><br>   _,ok:=s.allStudent[stuID]<br>   <span class="hljs-keyword">if</span> !ok&#123;<br>      fmt.Println(<span class="hljs-string">&quot;查无此人&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">//3.有的话就删除，从map中删除键值对</span><br>   <span class="hljs-built_in">delete</span>(s.allStudent,stuID)<br>   fmt.Println(<span class="hljs-string">&quot;删除成功！&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showMenu</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;欢迎使用学生管理系统！&quot;</span>)<br>   fmt.Println(<span class="hljs-string">`</span><br><span class="hljs-string">         1.查看所有学生</span><br><span class="hljs-string">         2.新增学生</span><br><span class="hljs-string">         3.修改学生</span><br><span class="hljs-string">         4.删除学生</span><br><span class="hljs-string">         5.退出</span><br><span class="hljs-string">      `</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   smr =studentMgr&#123;<br>      allStudent: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]student, <span class="hljs-number">100</span>), <span class="hljs-comment">//初始化-开辟空间</span><br>   &#125;<br>   <span class="hljs-keyword">for</span>&#123;<br>      <span class="hljs-comment">//1.打印菜单</span><br>      showMenu()<br>      <span class="hljs-comment">//2.等待用户选择要干什么</span><br>      fmt.Println(<span class="hljs-string">&quot;请输入你的选择:&quot;</span>)<br>      <span class="hljs-keyword">var</span> choice <span class="hljs-keyword">int</span><br>      fmt.Scanln(&amp;choice)<br>      fmt.Printf(<span class="hljs-string">&quot;你选择了%d这个选项\n&quot;</span>,choice)<br>      <span class="hljs-comment">//3.执行对应的函数</span><br>      <span class="hljs-keyword">switch</span> choice&#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         smr.showAllStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         smr.addStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         smr.editStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         smr.deleteStudent()<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>         os.Exit(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">default</span>:<br>         fmt.Println(<span class="hljs-string">&quot;输入错误！&quot;</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go语言基础语法</title>
    <link href="/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/11/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>我们利用变量将这个数据的内存地址保存起来，以后可以直接通过这个变量就能找到内存上对应的数据了。</p></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量有不同的类型，对应存储不同的数据类型：</p><p>常见的有以下几种：</p><ul><li><p>bool: 布尔型的值<strong>只</strong>可以是常量 true 或者 false</p></li><li><p><code>int</code>：存放整数</p><p>​          八进制以0开头     十六进制用ox开头</p></li><li><p><code>float32/float64(默认)</code>: 存放小数，两者不能直接互相赋值</p></li><li><p><code>string</code>: 存放一串字符</p></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Go语言中变量必须先声明再使用</p><p>我们用关键字<code>var</code>用于声明变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> <br><span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span> = <span class="hljs-number">9</span> <span class="hljs-comment">//声明并赋值，不赋值的话默认是初始值</span><br><span class="hljs-keyword">var</span> a, b, c <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;I&#x27;m a&quot;</span>, <span class="hljs-string">&quot;I&#x27;m b&quot;</span>, <span class="hljs-string">&quot;I&#x27;m c&quot;</span> <span class="hljs-comment">//也可以同时声明多个变量并赋值</span><br><span class="hljs-keyword">var</span> x, y = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">//也可以不指定变量的类型直接赋值，此时go语言会根据你赋予的值自动判断变量类型</span><br>num := <span class="hljs-number">123</span><br>str := <span class="hljs-string">&quot;Lengyusen&quot;</span> <span class="hljs-comment">//也可以用短声明:=来自动判断类型，只能在函数内用(常用)</span><br><span class="hljs-keyword">var</span>(<br>    name <span class="hljs-keyword">string</span><br>    age <span class="hljs-keyword">int</span><br>)<span class="hljs-comment">//批量声明</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Go语言中非全局变量声明了必须使用，不使用就无法编译</li><li>Go语言中推荐使用驼峰命名 如：studentName</li><li>关键词不能当作变量名</li><li>同一个作用域变量不能重复声明</li></ul><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量，用一个下划线<code>_</code>表示。不占用命名空间，不会分配内存</p><h2 id="常量与iota"><a href="#常量与iota" class="headerlink" title="常量与iota"></a>常量与iota</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><span class="hljs-comment">//和var一样，多个常量也可以一起声明</span><br><span class="hljs-keyword">const</span> (<br>    pi = <span class="hljs-number">3.1415</span><br>    e = <span class="hljs-number">2.7182</span><br>)<br></code></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><blockquote><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中<strong>每新增一行</strong>常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p></blockquote><p>几个常见的<code>iota</code>示例:</p><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2        <span class="hljs-comment">//1</span><br>_<br>n4        <span class="hljs-comment">//3</span><br>)<br></code></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2 = <span class="hljs-number">100</span>  <span class="hljs-comment">//100</span><br>n3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span><br>n4        <span class="hljs-comment">//3</span><br>)<br><span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_  = <span class="hljs-literal">iota</span><br>KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<span class="hljs-comment">//将1的二进制表示向左移10位</span><br>MB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>GB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>TB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>PB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>)<br></code></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//1,2</span><br>c, d                      <span class="hljs-comment">//2,3</span><br>e, f                      <span class="hljs-comment">//3,4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h3><ul><li>%T 查看类型</li><li>%v 查看变量值(万能)</li><li>%d 查看十进制</li><li>%b 查看二进制</li><li>%o 查看八进制</li><li>%x 查看十六进制</li><li>%s 查看字符串</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中字符串用双引号包裹的，而单引号包裹的是字符。当定义一个多行字符串时，需要用到`符号(键盘上ESC下面的键)，但是对所有的转义字符均无效，文本会原样输出。</p><h4 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h4><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>​      要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;我爱Go语言&quot;</span><br> s2:= []<span class="hljs-keyword">rune</span>(s1)<span class="hljs-comment">//把字符串强制转化为rune切片</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;你&#x27;</span><br>fmt.Println(<span class="hljs-keyword">string</span>(runeS2))<span class="hljs-comment">//把rune切片强制转化为字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1结果为true时，执行此处代码  </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件表达式<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-comment">//当条件表达式2结果为true时，执行此处代码 </span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//当条件表达式1，2结果为false时，执行此处代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环使Go语言中唯一的循环语句</p><pre><code> for循环的基本格式如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 初始语句;条件表达式;结束语句&#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><p>​    条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<span class="hljs-comment">//常用</span><br></code></pre></td></tr></table></figure><p>​    for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">   i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(i)<br>i++<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><p>​    无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    循环体语句<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。(一个break只能结束一层for循环)</li><li>for循环可以通过continue语句跳过此次循环。</li></ul><p>​    for range循环(键值循环)</p><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s:=<span class="hljs-string">&quot;Hello Leng&quot;</span><br><span class="hljs-keyword">for</span> i,v:=<span class="hljs-keyword">range</span> s&#123;<br>fmt.printf(<span class="hljs-string">&quot;%d %c\n&quot;</span>,i,v);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><p>​    使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo1</span><span class="hljs-params">()</span></span> &#123;<br>finger := <span class="hljs-number">3</span><br><span class="hljs-keyword">switch</span> finger &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>fmt.Println(<span class="hljs-string">&quot;大拇指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>fmt.Println(<span class="hljs-string">&quot;食指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>fmt.Println(<span class="hljs-string">&quot;中指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>fmt.Println(<span class="hljs-string">&quot;无名指&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>fmt.Println(<span class="hljs-string">&quot;小拇指&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;无效的输入！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>​    一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testSwitch3</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := <span class="hljs-number">7</span>; n &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo4</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">30</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> age &lt; <span class="hljs-number">25</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好学习吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">25</span> &amp;&amp; age &lt; <span class="hljs-number">35</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好工作吧&quot;</span>)<br><span class="hljs-keyword">case</span> age &gt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好享受吧&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;活着真好&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchDemo5</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;a&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;b&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">case</span> s == <span class="hljs-string">&quot;c&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;c&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><blockquote><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。</p></blockquote><p> 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-comment">// 设置退出标签</span><br><span class="hljs-keyword">goto</span> breakTag<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v-%v\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-comment">// 标签</span><br>breakTag:<br>fmt.Println(<span class="hljs-string">&quot;结束for循环&quot;</span>)<br><span class="hljs-comment">//尽量少用</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p></blockquote><p>我们可以在给数组声明的同时赋值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [<span class="hljs-number">5</span>]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-string">&quot;Max&quot;</span>&#125; <span class="hljs-comment">//括号中初始化的元素个数不能大于数组的大小</span><br></code></pre></td></tr></table></figure><p>还可以不设置数组大小，Go 语言会自动根据元素的个数来设置数组的大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> names = [...]<span class="hljs-built_in">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><blockquote><p>​        Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。切片是引用类型，不保存具体的值，都指向了底层的数组，如果修改切片，底层数组也会被修改。<strong>总而言之，切片就是一个框，框柱了一块连续的内存，切片属于引用类型，真正的数据都是保存在底层的数据之中的。</strong></p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name []T<br><span class="hljs-keyword">var</span> s1[]<span class="hljs-keyword">int</span><span class="hljs-comment">//存放int类型数据的切片</span><br>s1=[]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><h3 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h3><blockquote><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p></blockquote><ul><li>长度指的是切片中的元素个数</li><li>容量指的是切片对应的底层数组的元素个数，是底层数组从切片的第一个元素到最后一个元素的元素数量。</li></ul><h3 id="如何得到切片"><a href="#如何得到切片" class="headerlink" title="如何得到切片"></a>如何得到切片</h3><h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">a1:=&#123;...&#125;<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>&#125;<br>s1:=a1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7]基于一个数组切割，左包含右不包含</span><br>s2:=a1[:<span class="hljs-number">4</span>]<span class="hljs-comment">//[1 3 5 7] =&gt;[0:4]</span><br>s3:=a1[<span class="hljs-number">3</span>:]<span class="hljs-comment">//[7 9 11 13] =&gt;[3:len(a1)]</span><br>s4:=a1[:]<span class="hljs-comment">//[1 3 5 7 9 11 13] =&gt;[0:len(a1)]</span><br></code></pre></td></tr></table></figure><h4 id="make-函数创造切片"><a href="#make-函数创造切片" class="headerlink" title="make( ) 函数创造切片"></a>make( ) 函数创造切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">   a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">//长度为2，容量为10</span><br>fmt.Println(a)      <span class="hljs-comment">//[0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">//2</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(a)) <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><h4 id="索引遍历"><a href="#索引遍历" class="headerlink" title="索引遍历"></a>索引遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>fmt.Println(i, s[i])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for-range遍历"><a href="#for-range遍历" class="headerlink" title="for  range遍历"></a>for  range遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Println(index, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="append-为切片追加元素"><a href="#append-为切片追加元素" class="headerlink" title="append( )为切片追加元素"></a>append( )为切片追加元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)        <span class="hljs-comment">// [1]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">// [1 2 3 4]</span><br>s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;  <br>s = <span class="hljs-built_in">append</span>(s, s2...)    <span class="hljs-comment">// [1 2 3 4 5 6 7] ...表示拆开</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>我们需要用原切片变量接收返回值，当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。</li><li>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</li><li>Go语言中无删除切片元素的方法，可以利用append()函数把不要的元素切掉，此时底层数组也会被修改</li><li>通过切片会改变底层数组，拷贝前后两个切片共享底层数组，对一个切片的修改会影响另一个切片的内容。而使用copy函数可以防止此情况。</li><li>可以使用sort.Ints(s[:])对切片进行排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web后端-go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2021/11/14/%E6%A0%91/"/>
    <url>/2021/11/14/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种分支结构，逻辑上是一对多，具有明显的递归特性。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>结点：包含一个数据元素和若干指向子树的分支</li><li>结点的度：结点上分支的个数</li><li>数的度：所有结点的最大分支数(结点度的最大值)</li><li>叶子节点：度为零的节点(末端)</li><li>双亲、孩子：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</li><li>森林：多棵树放在一起</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的每个结点至多只有两棵子树，且子树有左右之分，次序不能颠倒</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>满二叉树：除了最底层每个结点都有左右两个孩子</li><li>完全二叉树：满二叉树从最底层开始从右往左删除结点，满二叉树是特殊的完全二叉树</li></ul><h4 id="求完全二叉树的高度-h"><a href="#求完全二叉树的高度-h" class="headerlink" title="求完全二叉树的高度(h)"></a>求完全二叉树的高度(h)</h4><p>解此类问题重在分析结点与高度之间的关系</p><p>1.先分析满二叉树</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\F06C28DB02E9D1EBA4077DD627BC071A.jpg"></p><p>2.一般的完全二叉树</p><p>​     方法①：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\B520005BA6A661BC36A5CBFEB8260729.jpg"></p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\C79655C54222BEC83BCDD60A33FBEC0E.jpg"></p><p>​     方法②：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\14F0AF8E1F1DD63E69940BA566D8B5B7.jpg"></p><p>综上有两个公式(我偏向于记忆第一个，因为第一个更便于理解)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\56EB97FA5643D36AB5D969D00686A794.jpg"></p><p>​                （注：第一个是向下取整，第二个是向上取整）</p><h3 id="二叉树的一些性质"><a href="#二叉树的一些性质" class="headerlink" title="二叉树的一些性质"></a>二叉树的一些性质</h3><ul><li><p>总分支数=总结点数-1</p><p>   叶结点个数为N0</p><p>   单分枝结点个数为N1</p><p>   双分支结点个数为N2</p></li><li><p>总结点数=N0+N1+N2</p></li><li><p>总分支数=N1+2N2</p><p>   <strong>从而解得：N0=N2+1</strong></p><p>​                     <strong>叶子结点数=双分支节点数+1</strong></p><p>（普通树可用同样的方法类比：N0=1+N2+2N3+…+(m-1)Nm）</p></li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>把每个结点存入数组之中(但只对完全二叉树适用)</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\6879E5CA54A244F6D9F13F05AD430235.jpg"></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>首先我们看看树的链式存储结构，用链表存储孩子结点的信息</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\31C74FFF31C21E4792E95A574724EBFF.jpg"></p><p>​     然后我们看二叉树，则可以表链表的长度取成二，但我们之所以用链表来存储数的信息，是因为链表方便存储不确定个数的信息。而我们现在已经知道了二叉树最多只有两个子树，所以我们可以直接定义两个指针来指向左右两个孩子。</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\1A256C933F8626A252683FEDD01EB861.jpg"></p><h3 id="数与二叉树的相互转换"><a href="#数与二叉树的相互转换" class="headerlink" title="数与二叉树的相互转换"></a>数与二叉树的相互转换</h3><p>​     方法：将数转化为二叉树：首先将每个结点与其兄弟结点相连，然后只留下最左边的连线，删去其他连线，最终形成的二叉树左边的连线是连的孩子，右边的连线是连的兄弟。而将二叉树转化为树则与上述操作相反即可，补全与双亲的连线，删去与兄弟的连线。下图是将树转化为二叉树的一个事例：</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\FB481DD3FAD88556E1850D77BCC54920.jpg" style="zoom:33%;"><h3 id="森林与二叉树的相互转换"><a href="#森林与二叉树的相互转换" class="headerlink" title="森林与二叉树的相互转换"></a>森林与二叉树的相互转换</h3><p>  方法：森林转化为二叉树：首先将森林中的每棵数都先转化为二叉树，则每棵二叉树根节点的左边接的是子树，右边为空，然后就可以让右边接下一棵树的根节点。而将二叉树转换为森林即实现相反操作。</p><img src="/2021/11/14/%E6%A0%91/安装\blog\source\_posts\树\0163938A33B279A3770AB24ED6D120FB.jpg" style="zoom: 25%;"><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>层次遍历(广度优先遍历)：从上至下，从左至右</p></li><li><p><em><strong>前序遍历：根-左-右</strong></em></p></li><li><p><em><strong>中序遍历：左-根-右</strong></em></p></li><li><p><em><strong>后序遍历：左-右-根</strong></em></p></li></ul><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\7B0ACC7E9692F5401BB179C67F32438C.jpg"></p><p>​        树的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\2FAE304F42ECD1CA3B8DF1C394672E85.jpg"></p><p>​        森林的遍历：</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\3C551A4C1BE1291709BC8F848781898A.jpg"></p><h4 id="递归函数基础"><a href="#递归函数基础" class="headerlink" title="递归函数基础"></a>递归函数基础</h4><p>函数自己调用自己</p><p><img src="/2021/11/14/%E6%A0%91/安装\blog\source_posts\树\EEC46EE6479E306BFF6318E5232F51BD.jpg"></p><h4 id="二叉树遍历以代码实现"><a href="#二叉树遍历以代码实现" class="headerlink" title="二叉树遍历以代码实现"></a>二叉树遍历以代码实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
